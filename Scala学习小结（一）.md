# 一、	前言
Scala 是一种混合了面向对象编程和函数式编程的特性的语言，由于我本人是从java转向Scala的，所以本文侧重于介绍总结和展示我在学习过程中使用函数式编程的一些体验。  

首先,函数式编程和面向对象编程只是软件开发的两种不同途径，并不对立。面向对象编程可以认为是一种自顶向下的程序设计方法，
我们一般通过名词（抽象为使用的对象）做切割，每个对象有状态，行为，标识符等，定义名词后，再进一步定义名词之间的交互，我们
需要将交互也放入对象中，通常会定义为服务类进行操作，一切皆为对象。而函数式编程中，一般将软件分解为需要执行的行为和操作，
可以认为是一种自底向上的设计方法，函数可以看作程序中的基本元素，取代了我们通常理解的变量。函数纯粹对输入进行操作，产生结
果，所有变量视为不可变的，并且尽可能的将副作用（状态的变化）推迟或消除，从而使得容易对程序进行推理。按照这个思路，我们可
以发现，函数式编程中单元测试和debug的难度大大降低了，因为变量不可变，所以程序运行中不会修改任何别的东西，决定函数结果的只
有输入，因而调试中的错误是百分之百不用花很多精力可以实现重现的，同时每个函数都可以单独的通过单元测试。还有一个重要的好处是
可以实现热部署，FP中所有状态都是传给函数的参数，而参数都是存储在栈上的，所以理论上只需要比较正在运行的代码和更新的代码获得
一个diff，然后利用这个diff更新现有代码，其他的交给语言工具自动完成就行了！  

下面我会从高阶函数，模式匹配，集合，数据结构，综合使用，框架的使用demo这六个我认为比较有代表性的方面来写这篇文章。  

# 二、 高阶函数
在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数：a.接受一个或多个函数作为输入,b.输出一个函数。在数学中它们也叫做算子（运算符）或泛函。微积分中的导数就是常见的例子，因为它映射一个函数到另一个函数。在无类型lambda演算，所有函数都是高阶的；在有类型lambda演算（大多数函数式编程语言都从中演化而来）中，高阶函数一般是那些函数型别包含多于一个箭头的函数。在函数式编程中，返回另一个函数的高阶函数被称为Curry化的函数。在很多函数式编程语言中能找到的map函数是高阶函数的一个例子。它接受一个函数f作为参数，并返回接受一个列表并应用f到它的每个元素的一个函数。  

通俗的讲，我们可以将高阶函数理解为可以接受函数作为参数传入，也可以将函数作为结果输出的函数，即函数为一等公民，函数可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，可以对函数进行任意组合。  

可能有些人和我一样有这样的疑问：道理我都懂，可是这些特性真的有用吗？事实上，一切皆视为函数可以进一步增加我们的代码的可重用性，将重用的细粒度提升到了函数，与此同时，在数据的处理方面拥有着巨大的优势。下面通过几段对比代码来显示高阶函数和函数式编程的有趣之处。  

我们来到一个兑换零钱的需求场景，首先你有一个金币总和，请问有多少种方法可以兑换。按照常识，金币的面值有1,2,5.于是乎，我们写出了下面的代码。
``` java
public static int countChange(int sum)  {
    int s=0;
    for(int i=0;i<=sum/5;i++){
        for(int j=0;j<=(sum-i*5)/2;j++){
            for(int k=0;k<=(sum-i*5-j*2);k++){
                if(5*i+2*j+k==sum){
                    s++;
                    System.out.println(i+"*5 + "+j+"*2 + "+k+"*1 = "+sum);
                }
            }
        }
    }
    return s;
}
```
看起来很美，但是过了几天领导告诉你，需求变了，要添加别的面值的金币。没关系，我可以继续嵌套for循环进去啊，终于有一天，代码臃肿到你不能忍了，于是你想到，我要去写一个通用的方法。于是乎，你对方法进行了重构。  

这个时候，我们换个思路，来到了函数式编程中，便可以写出如下的代码:
``` scala
def countChange(money: Int, coins: List[Int]): Int = {
  val l = coins.sorted.reverse
  if (l.isEmpty || money < 0) 0
  else if (l.tail.isEmpty && money % l.head == 0) 1
  else countChange(money - l.head, l) + countChange(money, l.tail)
}
```
是不是简洁了许多，只需要一行代码，就能完成对集合的排序操作，然后，你只需要理顺逻辑需求，告诉机器需要做什么就可以了，至于如何做剩下的就交给计算机来计算了。其实，这就是编程中的一种递归的思想，当然我们还可以继续优化，此处就不做继续赘述了。







